---
layout: post
title: 《Java并发编程的艺术》读书笔记-第一章
date: 2018-09-08 14:16:45 +0800
categories: Java并发
tags: [Java并发]
---

本文是《Java并发编程的艺术》第一章的读书笔记，这个系列我将以总结知识点为主，形成流水式的笔记，以便于未来回查。

# 第一章-并发编程的挑战

## 导言

并发编程可以使程序运行更快（可以提高CPU使用率，减少空转等），但并不是线程越多越好，并发编程还要面对如上下文切换、资源限制、死锁等问题的挑战。

## 1.1 上下文切换

单核CPU通过分配时间片给多个线程来实现多线程，时间片很短（几十ms），因为CPU不停地在多个线程间切换运行，所以能得到一种多线程执行的现象。

##### 我想：

>单线程的时代，在同一时间只能执行一个线程，直到线程结束，这听起来就像上世纪的DOS一样，我们执行了一个程序，必须等到它结束才能执行下一个程序，现代操作系统已经实现通过调度器控制线程运行的功能，因此可以由操作系统调度CPU资源（时间片）分配给线程运行，以此实现“多线程”，但实际上CPU仍然是单线程的（因为CPU只能一条一条指令顺序地运行）。
>
>CPU不停地切换线程运行，营造出多线程执行的现象，有点像以前我学习51单片机时做的第一个DEMO，是在一个数字显示器上显示数字，实际上单片机代码里，显示一次只能加一下电给显示器，时间很短，然后显示器就黑了，比如要显示1，在代码里只显示一次的话，显示器上就只能闪一下，但如果写一个循环，让这个1不停循环地显示，显示器就会由于不停地加电显示1,表现出一种一直显示1的现象，这里显示1就像是一个线程在运行，不停地显示1就像CPU不停地切换线程执行，一会让其他线程执行，一会让这个线程执行，当时间片很短，切换速度很快时，表现出来的就像是这个线程在不停执行一样。

为什么要上下文切换：因为在线程执行时，使用的CPU资源有CPU的指令寄存器存下一条指令的内存位置，有各个寄存器存操作数，有很多其他的执行相关的数据，不同线程间这些数据肯定是不同的，因此在线程切换时，这些数据需要进行切换，上下文切换就是一个保存当前线程的执行现场，恢复另一个线程的执行现场的过程。

##### 我想

>线程切换是有代价的，这是一个操作系统、CPU、各个硬件互相配合的过程，保存和恢复执行现场是要花费时间的，而单线程的任务则无需考虑线程切换的这种性能损耗。

### 1.1.1 多线程一定快吗

本节用一个Java例子来展示多线程和单线程在处理数据时的速度，主要代码是一段累加动作，变量是累加次数，对比在main线程和main线程下新建线程在不同累加次数下的执行时间。对比的结果是当累加次数很小时，新建线程的运行时间反而不大于甚至小于mian线程下直接执行。

出现这种现象的原因是当累加消耗的时间小于线程切换的时间时，单线程的效率就会高于多线程。

##### 我想

>这个例子我们现实里并不会遇到，但是线程切换的性能损耗是必需要考虑的，比如在某些情况下，使用自旋锁的程序执行效率要比使用互斥锁效率高，究其原因，是因为自旋锁会保持程序执行，而互斥锁则会挂起线程，引起线程切换。

### 1.1.2 测试上下文切换次数和时长

在Unix系统下，可以使用vmstat的CS(Context Switch)数据来监控线程切换次数，也可以使用Lmbench3来测试。

在Windows下，可以使用Process Explorer来监控。

### 1.1.3 如何减少上下文切换

1. 无锁并发编程，锁会引起上下文切换，减少锁的使用，不使用锁都会避免线程上下文切换
2. CAS算法，也是一种无锁并发操作共享资源的方式
3. 使用最少线程，避免创建不必要的线程
4. 协程，在单线程里实现多任务的调度，并在单线程里维持多个任务的切换，是一种比线程粒度更小的工作单位。（C10M，多线程编程的未来）

## 1.2 死锁

当多个线程竞争同一个锁资源，但持有锁资源的那个线程永远不会释放这个锁时，就会造成死锁。

本节用了一个例子，使用两个锁，两个线程，其中一个线程A先拿锁a，然后挂起5秒，同时另一个线程B拿到锁b，然后挂起5秒。线程A在5秒后唤醒，请求锁b，但锁b被线程B拿到，因此线程A进入阻塞等锁状态，同时线程B在5秒后唤醒，请求锁a，但锁a被线程A拿到，因此线程B进入阻塞等锁状态，最后线程AB都阻塞在等待对方释放锁的情况，永远不会拿到锁，也不会继续运行，就成为死锁状态了。

现实中，应该避免在加锁的代码内进行可能造成死锁的操作，打个比方，程序里有一段针对数据库锁表的SQL操作，因为意外程序退出，但没有及时释放表锁，于是后续操作表的SQL都会因为拿不到表锁于是进入阻塞状态，程序无法运行，直到数据库自动释放锁或重启了数据库。如果在程序异常退出时，加了一段解锁的代码，那么就不会出现这种情况了。

这里介绍了几个避免死锁的方法：

1. 避免一个线程同时获取多个锁。（每个锁都代表其背后有一群被阻塞的线程，锁与锁之间还可能互相造成死锁，就像上面的例子一样）
2. 避免一个线程在一个锁内占用多个资源，尽量保证每个锁只占用一个资源。（操作资源的过程可能程序会错误退出，没有正确释放资源，造成其他线程请求资源失败；或是操作资源时间过长，造成其他线程等锁时间过久）
3. 尝试使用定时锁，使用lock.tryLock(timeout)来替代内部锁机制。
4. 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则可能会出现解锁失败的情况。

## 1.3 资源限制的挑战

### 1 什么是资源限制

并发编程下，程序执行速度受限于计算机硬件资源或软件资源，比如网络带宽是1Mb/s，那么开10个线程下载也不会变成10Mb/s。

硬件资源一般有网络带宽、CPU执行速度、硬盘内存读写速度。

软件资源有数据库连接数、Socket连接数等。

### 2 资源限制引发的问题

并发编程中，加速的原则是将代码中串行执行的部分变成并发执行，但由于资源限制，可能会导致并发执行的代码仍然以串行方式执行，这样程序效率反而会更低，因为增加了上下文切换和资源调度的时间。

### 3 如何解决资源限制的问题

集群的使用。

连接复用。

### 4 在资源限制情况下进行并发编程

根据具体的资源来调整并发数或是直接使用单线程执行。

##### 我想

>资源限制这一段还是比较模糊的，因为太涉及实战了，影响一个程序执行效率的因素有很多，CPU时钟速度、内存读写速度、硬盘读写速度、操作系统调度、网络带宽、设备访问速度、资源访问速度、锁的使用、代码实践、线程数量、线程栈大小(线程栈、堆、操作系统内核都要用内存，要算出多大的空间是最好的，避免频繁GC拖慢程序运行)等等等等，有的时候我们需要不停地测试线程数和执行效率的关系，或是在纸面上通过计算算出最好的线程数，这需要我们深入了解计算机原理，明白哪些参数会影响程序执行效率，并且有公式可以计算出最好的线程数，所以这一段很模糊也很正常，因为太宽泛了，所以还是好好积累吧。