---
layout: post
title:  数据结构1-绪论
date:   2018-06-24 22:19:30 +0800
categories: data-structure
tags: [data-structure]
---

从今天起更新一套数据结构学习笔记。

这套笔记更偏向于进行一些知识点的复习时使用，因此阅读要求是至少学习过数据结构的课程，不会拿本文作为入门学习，因此很多基础概念也不会做太多解释，望活用搜索引擎。

## 导论

数据结构在代码实践中是很重要的，我们经常说一个程序等于算法加数据结构，也就描述了数据结构的重要性，因此从今天起，我将学习并更新一套数据结构的学习笔记。

数据结构是一个偏向于在实际问题中进行研究的课程，在解决实际问题时，我们要分析问题中的数据，得出数据之间的逻辑关系，然后根据具体的问题算法，选择与之相匹配的数据存储结构，进而得出整个数据结构，整个过程之间的关系如下：

问题——>画出逻辑关系——>定义存储结构（物理）——>实现操作

整理一下这个过程，可以得出：

数据结构=数据的逻辑关系+数据的物理存储结构

因此数据间的关系可以概括为逻辑关系和物理关系。其中逻辑关系表现了数据间的关系，物理存储结构则决定了数据结构可以实现的操作，具体我们可以在后面的课程中了解到。

## 数据间的关系

其中，数据的逻辑关系可以概括为四类：

1. 集合：数据之间没有任何关系，他们仅仅被放在了一个范围内，比如说同一个猪圈里的猪。
2. 线型：数据之间是1:1的关系，比如说先后顺序，一月、二月...十二月就是一个典型的线型关系。
![](http://mcace.me/assets/images/2018/data-structure/chapter1/img1.jpg)
3. 树型：数据之间有层级，并且高层的数据可以对应多个下层数据，比如一个公司的人员组织结构就是典型的树形关系。
![](http://mcace.me/assets/images/2018/data-structure/chapter1/img2.jpg)
4. 图型：数据之间是多对多的关系，比如地图上某个区域的多个建筑，每个建筑都可以连通多个其他建筑，他们之间的道路连通就是多对多的关系，这就是典型的图型关系。  
![](http://mcace.me/assets/images/2018/data-structure/chapter1/img3.jpg)

而物理存储结构，则是数据保存在内存中的形式。

关于数据保存在内存中我简单的形容一下：我们的程序运行在计算机上，其中大部分运行时需要的数据是保存在内存中的，内存可以看成是一个单列的文件柜，文件柜的每个抽屉里存储的就是数据，而存储的位置之间是有先后关系的，类似于下图。
![](http://mcace.me/assets/images/2018/data-structure/chapter1/img4.jpg)  
并且每个存储位置都是有它唯一的物理地址的，现阶段我们可以单纯地将物理地址看作是从下往上，从1开始逐渐变大，也就是图中绿色的数字。

物理存储结构也可以概括为四类，这里我们拿数据量为3时来举例：

1. 顺序存储结构：存储的数据按照一定顺序在对应位置存储的，并且在物理结构上是互相挨着的，比如文件柜图中的1-3、2-4、5-6区域按顺序存储所有数据。
2. 链式存储结构：存储的数据在物理结构上没有固定的位置，但也会有顺序，每个数据节点都会保存下个数据节点的地址，因此才能实现物理结构上的随意存放，举个例子：位置2存放数据节点1，同时数据节点1内存放了数据节点2的物理位置4，而数据节点2则存放了数据节点3的物理位置1。如下图：  
![](http://mcace.me/assets/images/2018/data-structure/chapter1/img5.jpg)  
   这样就形成了一个像链条一样互相串联的数据结构：  
![](http://mcace.me/assets/images/2018/data-structure/chapter1/img6.jpg)  
3. 散列
4. 索引

数据结构中，最主要的存储结构是顺序存储和链式存储，而另外两种存储方式，也会在后续再详细介绍一下。

而针对存储结构的具体操作，我们可以认为主要的操作为插入、删除、查询、修改，也就是在JAVA WEB中常有的增删改查(crud)操作。但不同的存储结构，决定了对其进行操作时的效率不同，举例来说，一个顺序存储结构，删除其中一个数据节点，那么它后面的所有数据节点就要往前移动一位，来填补删除后出现的空白，而链式存储结构删除数据节点，则只需要将该节点的前后节点相连，就可以达到无法再访问该节点的目的，删除这个操作对于这两种存储结构来说，效率是完全不一样的，顺序存储结构的删除时间复杂度为O(N),而链式则为O(1)。

## 大O记法

__在考察程序时间复杂度时，使用O(x)来进行表达__，举例来说，一个有n个元素的数组从头遍历到尾，则时间复杂度为O(n)，而取第x个元素，对于顺序存储结构则是直接拿到头节点的地址加上偏移量x就可以取到指定元素，那么这样的时间复杂度为O(1)，但对于链式存储结构，由于没有办法直接确定第x个元素的地址，因此需要从头开始向后遍历到第x个元素，所以时间复杂度为O(n)。

__大O记法表示的是程序执行耗费的时间随着数据量变化的变化趋势__，比如一个O(1)时间复杂度的程序，无论数据量怎么变，程序执行时间都是一个常数，而O(n)则是随着数据量变大，程序执行时间呈线性增长趋势，线性增长可以想象成在一个二维坐标系里，x轴表示数据量，y轴表示时间复杂度的情况下，表示执行时间与数据量关系的函数为y=ax，其中a为常数，因此这个函数描绘出来是一条直线。除此之外还有O(logn)、O(n^2)，都可以看作是y=alogn，y=an^2所描绘的图形，也就是对数级增长和指数级增长。

## 阶段整理

下面是上述文字的阶段整理导图

![](http://mcace.me/assets/images/2018/data-structure/chapter1/img7.jpg)  